/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const GameBoard = __webpack_require__(/*! ./gameboard */ \"./src/gameboard.js\");\r\nconst Player = __webpack_require__(/*! ./player */ \"./src/player.js\");\r\nconst View = __webpack_require__(/*! ./view */ \"./src/view.js\");\r\n\r\n// game loop\r\n// create players and boards\r\nconst boardPlayer1 = GameBoard();\r\nboardPlayer1.populateRandomly();\r\nconst boardPlayer2 = GameBoard();\r\nboardPlayer2.populateRandomly();\r\nconst player1 = Player(boardPlayer1, boardPlayer2);\r\nconst player2 = Player(boardPlayer2, boardPlayer1, false);\r\n\r\n// creating the boards in the dom\r\nconst view = View();\r\nview.prepareGameBoard(['player1Board']);\r\nview.shipPlacement(boardPlayer1, '.player1Board');\r\n// create the boards after shipplacement\r\n// view.prepareGameBoard(['player1Board', 'player2Board']);\r\n// view.renderBoard(boardPlayer1, '.player1Board');\r\n// view.renderBoard(boardPlayer2, '.player2Board', false);\r\n\r\n// test assets\r\nlet carrier = document.querySelector('#carrier');\r\nlet img = document.createElement('img');\r\nimg.src = '../src/test_assets/a9.png';\r\nimg.setAttribute('draggable', true);\r\nimg.setAttribute('id', 'testdragging');\r\nimg.setAttribute('ondragstart', 'drag(event)');\r\ncarrier.appendChild(img);\r\n\r\n// set player1 active\r\nplayer1.active = true;\r\n\r\n// add eventlistener for click on enemy board\r\n// document.querySelector('.player2Board').addEventListener('click', e => {\r\n//   const x = e.target.dataset.x;\r\n//   const y = e.target.dataset.y;\r\n//   // only execute if the player didn't already click on this field\r\n//   if (boardPlayer2.isValidTarget([x, y])) {\r\n//     let player1Result = boardPlayer2.receiveAttack([x, y]);\r\n//     if (player1Result.sunk === true) console.log('enemy ship sunk!');\r\n//     if (player1Result.remaining == 0) console.log('congratz, you won');\r\n//     // render gameboard again\r\n//     view.renderBoard(boardPlayer2, '.player2Board', false);\r\n//     // set player2 active and handle his attack\r\n//     let player2Result = player2.attack();\r\n//     view.renderBoard(boardPlayer1, '.player1Board');\r\n//     if (player2Result.remaining == 0) console.log('player 2 won');\r\n//   }\r\n// });\r\n\n\n//# sourceURL=webpack://battleship/./src/game.js?");

/***/ }),

/***/ "./src/gameboard.js":
/*!**************************!*\
  !*** ./src/gameboard.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Ship = __webpack_require__(/*! ./ship */ \"./src/ship.js\");\r\n\r\nconst GameBoard = () => {\r\n  let ships = [];\r\n  let shipTypes = [\r\n    { type: 'Carrier', length: 5 },\r\n    { type: 'Battleship', length: 4 },\r\n    { type: 'Destroyer', length: 3 },\r\n    { type: 'Submarine', length: 3 },\r\n    { type: 'Patrol Boat', length: 2 }\r\n  ];\r\n  let minCoords = 1;\r\n  let maxCoords = 10;\r\n  let board = [];\r\n  for (let x = minCoords; x <= maxCoords; x++) {\r\n    for (let y = minCoords; y <= maxCoords; y++) {\r\n      board.push({\r\n        x: x,\r\n        y: y,\r\n        hasShip: false,\r\n        isHit: false\r\n      });\r\n    }\r\n  }\r\n\r\n  function placeShip(coords) {\r\n    const ship = Ship(coords);\r\n    // check for placing ships on top of each other\r\n    let conflict = [];\r\n    ship.position.forEach(pos => {\r\n      // skip execution if we already found a conflict\r\n      if (conflict.length <= 0) {\r\n        conflict = board.filter(field => {\r\n          return (\r\n            // check the field itself\r\n            (field.x === pos.x &&\r\n              field.y === pos.y &&\r\n              field.hasShip === true) ||\r\n            // check the field to the right\r\n            (field.x === pos.x + 1 &&\r\n              field.y === pos.y &&\r\n              field.hasShip === true) ||\r\n            // check the field to the left\r\n            (field.x === pos.x - 1 &&\r\n              field.y === pos.y &&\r\n              field.hasShip === true) ||\r\n            // check the field below\r\n            (field.x === pos.x &&\r\n              field.y === pos.y + 1 &&\r\n              field.hasShip === true) ||\r\n            // check the field above\r\n            (field.x === pos.x &&\r\n              field.y === pos.y - 1 &&\r\n              field.hasShip === true) ||\r\n            // check the fields diagonally:\r\n            // right + below\r\n            (field.x === pos.x + 1 &&\r\n              field.y === pos.y + 1 &&\r\n              field.hasShip === true) ||\r\n            // right + above\r\n            (field.x === pos.x + 1 &&\r\n              field.y === pos.y - 1 &&\r\n              field.hasShip === true) ||\r\n            // left + above\r\n            (field.x === pos.x - 1 &&\r\n              field.y === pos.y - 1 &&\r\n              field.hasShip === true) ||\r\n            // left + below\r\n            (field.x === pos.x - 1 &&\r\n              field.y === pos.y + 1 &&\r\n              field.hasShip === true)\r\n          );\r\n        });\r\n      }\r\n    });\r\n    if (conflict.length > 0) return false;\r\n    // check for placing ships outside the board\r\n    if (\r\n      coords[0][0] < minCoords ||\r\n      coords[0][0] > maxCoords ||\r\n      coords[0][1] < minCoords ||\r\n      coords[0][1] > maxCoords ||\r\n      coords[1][0] < minCoords ||\r\n      coords[1][0] > maxCoords ||\r\n      coords[1][1] < minCoords ||\r\n      coords[1][1] > maxCoords\r\n    ) {\r\n      return false;\r\n    }\r\n    // place the coords on the board\r\n    ship.position.forEach(pos => {\r\n      board.map(field => {\r\n        if (field.x === pos.x && field.y === pos.y) {\r\n          field.hasShip = true;\r\n        }\r\n      });\r\n    });\r\n    ships.push(ship);\r\n    return true;\r\n  }\r\n\r\n  function getBoard() {\r\n    return board;\r\n  }\r\n\r\n  function populateRandomly() {\r\n    shipTypes.forEach(ship => {\r\n      let success;\r\n      do {\r\n        // create two random numbers between 1 and 10. This will be our starting coordinate\r\n        let randStartX = Math.floor(Math.random() * 10) + 1;\r\n        let randStartY = Math.floor(Math.random() * 10) + 1;\r\n        let randStartCoord = [randStartX, randStartY];\r\n        // create another arbitrary number to choose between vertical and horizontal placement\r\n        // create our end coordinate: x or y will be the same, depending if vertically or horizontally arranged\r\n        // create the other coordinate by adding ship.length - 1 and the x or y coordinate\r\n        // check if the calculated number is greater than 10: if so, instead subtract ship.length + 1\r\n        let randEndCoord = [];\r\n        if (Math.random() < 0.5) {\r\n          // horizontal\r\n          let randEndX = randStartX + ship.length - 1;\r\n          if (randEndX > 10) randEndX = randStartX - ship.length + 1;\r\n          randEndCoord.push(randEndX);\r\n          randEndCoord.push(randStartY);\r\n        } else {\r\n          // vertical\r\n          let randEndY = randStartY + ship.length - 1;\r\n          if (randEndY > 10) randEndY = randStartY - ship.length + 1;\r\n          randEndCoord.push(randStartX);\r\n          randEndCoord.push(randEndY);\r\n        }\r\n        // place the ship\r\n        let finalCoords = [randStartCoord, randEndCoord];\r\n        success = placeShip(finalCoords);\r\n        // we need to try placing the ship until a valid position is found\r\n      } while (success !== true);\r\n    });\r\n  }\r\n\r\n  function receiveAttack(coords) {\r\n    let hitInfo = {};\r\n    board.map(field => {\r\n      if (field.x == coords[0] && field.y == coords[1]) {\r\n        field.isHit = true;\r\n        // if there is a ship on this field, invoke it's hit function\r\n        if (field.hasShip) {\r\n          // get the ship that was hit by filtering the ships array for a ship that contains the coordinates in its position array\r\n          const ship = ships.filter(ship => {\r\n            return ship.position.some(pos => {\r\n              return pos.x == coords[0] && pos.y == coords[1];\r\n            });\r\n          })[0];\r\n          ship.hit(coords);\r\n          hitInfo.sunk = ship.sunk;\r\n          hitInfo.length = ship.length;\r\n          hitInfo.remaining = ships.filter(ship => ship.sunk === false).length;\r\n        }\r\n      }\r\n    });\r\n    if (hitInfo.length > 0) return hitInfo;\r\n    return false;\r\n  }\r\n\r\n  /** Returns true if the targeted field was not hit before, otherwise false */\r\n  function isValidTarget(coords) {\r\n    return board.some(field => {\r\n      return (\r\n        field.x == coords[0] && field.y == coords[1] && field.isHit === false\r\n      );\r\n    });\r\n  }\r\n\r\n  return {\r\n    ships,\r\n    placeShip,\r\n    getBoard,\r\n    receiveAttack,\r\n    populateRandomly,\r\n    isValidTarget\r\n  };\r\n};\r\n\r\nmodule.exports = GameBoard;\r\n\n\n//# sourceURL=webpack://battleship/./src/gameboard.js?");

/***/ }),

/***/ "./src/player.js":
/*!***********************!*\
  !*** ./src/player.js ***!
  \***********************/
/***/ ((module) => {

eval("const Player = (playerGameboard, enemyGameboard, isHuman = true) => {\r\n  let active = false;\r\n  /** This object is used by the computer player to save information about a ship\r\n   * that was successfully hit, enabling it, to make smarter guesses */\r\n  let successfullyHit = {};\r\n\r\n  /** This array will hold the coordinates that the computer player excludes,\r\n   * e. g. neighbors of a field that contains a ship, since on such a field now ship\r\n   * could be placed according to the rules */\r\n  const excluded = [];\r\n\r\n  /** This array tracks the lengths of the remaining enemy ships. It is used to\r\n   * make the AI smarter by checking if the randomly chosen coordinate has enough\r\n   * free fields to contain a ship */\r\n  const enemyShipLengths = [2, 3, 3, 4, 5];\r\n\r\n  function target(coords) {\r\n    return enemyGameboard.receiveAttack(coords);\r\n  }\r\n\r\n  /** Returns true if the coordinate is part of the excluded array */\r\n  function isExcluded(coords) {\r\n    return excluded.some(\r\n      coord => coord[0] == coords[0] && coord[1] == coords[1]\r\n    );\r\n  }\r\n\r\n  /** Returns true if the largest remaining ship may be placed on this\r\n   * coordinate (that means, there are enough fields in at least one direction,\r\n   * which have not been hit or excluded) */\r\n  function isPossiblePosition(coords) {\r\n    const longestShipLength = Math.max(...enemyShipLengths);\r\n    /** counters start at 1, because the targeted field itself must be counted too\r\n     * (otherwise the function would check for 1 field more then the greatest ship length!) */\r\n    let counterHorizontal = 1;\r\n    let counterVertical = 1;\r\n    // check how many fields are valid to the left.\r\n    for (let i = 1; i <= longestShipLength; i++) {\r\n      if (\r\n        enemyGameboard.isValidTarget([coords[0] - i, coords[1]]) &&\r\n        !isExcluded([coords[0] - i, coords[1]])\r\n      ) {\r\n        counterHorizontal++;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    // if >= longestShipLength, return true\r\n    if (counterHorizontal >= longestShipLength) return true;\r\n\r\n    // check how many fields are valid to the right.\r\n    for (let i = 1; i <= longestShipLength; i++) {\r\n      if (\r\n        enemyGameboard.isValidTarget([coords[0] + i, coords[1]]) &&\r\n        !isExcluded([coords[0] + i, coords[1]])\r\n      ) {\r\n        counterHorizontal++;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    // if free fields to the left + fields to the right >= longestShipLength, return true\r\n    if (counterHorizontal >= longestShipLength) return true;\r\n\r\n    // check how many fields are valid above.\r\n    for (let i = 1; i <= longestShipLength; i++) {\r\n      if (\r\n        enemyGameboard.isValidTarget([coords[0], coords[1] - i]) &&\r\n        !isExcluded([coords[0], coords[1] - i])\r\n      ) {\r\n        counterVertical++;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    // if >= longestShipLength, return true\r\n    if (counterVertical >= longestShipLength) return true;\r\n\r\n    // check how many fields are valid below\r\n    for (let i = 1; i <= longestShipLength; i++) {\r\n      if (\r\n        enemyGameboard.isValidTarget([coords[0], coords[1] + i]) &&\r\n        !isExcluded([coords[0], coords[1] + i])\r\n      ) {\r\n        counterVertical++;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    // if free fields above + below >= longestShipLength, return true\r\n    if (counterVertical >= longestShipLength) return true;\r\n    return false;\r\n  }\r\n\r\n  /** Helper that pushes coords into the excluded array. First the coords are checked if they are valid coordinates */\r\n  function exclude(obj) {\r\n    let coordsX = obj.coordsX;\r\n    let coordsY = obj.coordsY;\r\n    // if the ship is horizontal\r\n    if (coordsX.length > 1) {\r\n      // push above and below\r\n      coordsX.forEach(x => {\r\n        let above = coordsY[0] - 1;\r\n        let below = coordsY[0] + 1;\r\n        if (above <= 10 && above > 0) excluded.push([x, above]);\r\n        if (below <= 10 && below > 0) excluded.push([x, below]);\r\n      });\r\n      // push the sides, including diagonal fields\r\n      let start = Math.min(...coordsX) - 1;\r\n      let end = Math.max(...coordsX) + 1;\r\n      if (\r\n        coordsY[0] - 1 <= 10 &&\r\n        coordsY[0] - 1 > 0 &&\r\n        start <= 10 &&\r\n        start > 0\r\n      )\r\n        excluded.push([start, coordsY[0] - 1]);\r\n      if (\r\n        coordsY[0] + 1 <= 10 &&\r\n        coordsY[0] + 1 > 0 &&\r\n        start <= 10 &&\r\n        start > 0\r\n      )\r\n        excluded.push([start, coordsY[0] + 1]);\r\n      if (coordsY[0] <= 10 && coordsY[0] > 0 && start <= 10 && start > 0)\r\n        excluded.push([start, coordsY[0]]);\r\n      if (coordsY[0] - 1 <= 10 && coordsY[0] - 1 > 0 && end <= 10 && end > 0)\r\n        excluded.push([end, coordsY[0] - 1]);\r\n      if (coordsY[0] + 1 <= 10 && coordsY[0] + 1 > 0 && end <= 10 && end > 0)\r\n        excluded.push([end, coordsY[0] + 1]);\r\n      if (coordsY[0] <= 10 && coordsY[0] > 0 && end <= 10 && end > 0)\r\n        excluded.push([end, coordsY[0]]);\r\n    }\r\n    // if the ship is vertical\r\n    else if (coordsY.length > 1) {\r\n      // push above and below\r\n      coordsY.forEach(y => {\r\n        let left = coordsX[0] - 1;\r\n        let right = coordsX[0] + 1;\r\n        if (left <= 10 && left > 0) excluded.push([left, y]);\r\n        if (right <= 10 && right > 0) excluded.push([right, y]);\r\n      });\r\n      // push the sides, including diagonal fields\r\n      let start = Math.min(...coordsY) - 1;\r\n      let end = Math.max(...coordsY) + 1;\r\n      if (\r\n        coordsX[0] - 1 <= 10 &&\r\n        coordsX[0] - 1 > 0 &&\r\n        start <= 10 &&\r\n        start > 0\r\n      )\r\n        excluded.push([coordsX[0] - 1, start]);\r\n      if (\r\n        coordsX[0] + 1 <= 10 &&\r\n        coordsX[0] + 1 > 0 &&\r\n        start <= 10 &&\r\n        start > 0\r\n      )\r\n        excluded.push([coordsX[0] + 1, start]);\r\n      if (coordsX[0] <= 10 && coordsX[0] > 0 && start <= 10 && start > 0)\r\n        excluded.push([coordsX[0], start]);\r\n      if (coordsX[0] - 1 <= 10 && coordsX[0] - 1 > 0 && end <= 10 && end > 0)\r\n        excluded.push([coordsX[0] - 1, end]);\r\n      if (coordsX[0] + 1 <= 10 && coordsX[0] + 1 > 0 && end <= 10 && end > 0)\r\n        excluded.push([coordsX[0] + 1, end]);\r\n      if (coordsX[0] <= 10 && coordsX[0] > 0 && end <= 10 && end > 0)\r\n        excluded.push([coordsX[0], end]);\r\n    }\r\n  }\r\n\r\n  function attack() {\r\n    if (!isHuman) {\r\n      let x, y;\r\n      let result;\r\n      if ('coordsX' in successfullyHit) {\r\n        x = Math.min(successfullyHit.coordsX);\r\n        y = Math.min(successfullyHit.coordsY);\r\n        let left = Math.min(...successfullyHit.coordsX) - 1;\r\n        let right = Math.max(...successfullyHit.coordsX) + 1;\r\n        let above = Math.min(...successfullyHit.coordsY) - 1;\r\n        let below = Math.max(...successfullyHit.coordsY) + 1;\r\n        // try left first: if we already hit left before, it will be no valid target and the condition is skipped anyway\r\n        if (enemyGameboard.isValidTarget([left, y]) && !isExcluded([left, y])) {\r\n          result = target([left, y]);\r\n          if (result.length > 0) {\r\n            successfullyHit.coordsX.push(left);\r\n          }\r\n        } else if (\r\n          enemyGameboard.isValidTarget([right, y]) &&\r\n          !isExcluded([right, y])\r\n        ) {\r\n          result = target([right, y]);\r\n          if (result.length > 0) {\r\n            successfullyHit.coordsX.push(right);\r\n          }\r\n        } else if (\r\n          enemyGameboard.isValidTarget([x, above]) &&\r\n          !isExcluded([x, above])\r\n        ) {\r\n          result = target([x, above]);\r\n          if (result.length > 0) {\r\n            successfullyHit.coordsY.push(above);\r\n          }\r\n        } else if (\r\n          enemyGameboard.isValidTarget([x, below]) &&\r\n          !isExcluded([x, below])\r\n        ) {\r\n          result = target([x, below]);\r\n          if (result.length > 0) {\r\n            successfullyHit.coordsY.push(below);\r\n          }\r\n        }\r\n        // now, check if the ship was sunk. if so, reset successfullyHit\r\n        if (result.sunk === true) {\r\n          exclude(successfullyHit);\r\n          // remove length of the sunk ship\r\n          enemyShipLengths.splice(enemyShipLengths.indexOf(result.length), 1);\r\n          successfullyHit = {};\r\n        }\r\n      } else {\r\n        // if no hit was scored previously, choose random\r\n        do {\r\n          x = Math.floor(Math.random() * 10 + 1);\r\n          y = Math.floor(Math.random() * 10 + 1);\r\n        } while (\r\n          !enemyGameboard.isValidTarget([x, y]) ||\r\n          isExcluded([x, y]) ||\r\n          !isPossiblePosition([x, y])\r\n        );\r\n        result = target([x, y]);\r\n        if (result.length > 0) {\r\n          successfullyHit.coordsX = [x];\r\n          successfullyHit.coordsY = [y];\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n  }\r\n\r\n  return { isHuman, active, target, attack, isPossiblePosition, excluded };\r\n};\r\n\r\nmodule.exports = Player;\r\n\n\n//# sourceURL=webpack://battleship/./src/player.js?");

/***/ }),

/***/ "./src/ship.js":
/*!*********************!*\
  !*** ./src/ship.js ***!
  \*********************/
/***/ ((module) => {

eval("const Ship = coords => {\r\n  let position = setPosition(coords);\r\n  let length = position.length;\r\n  let sunk = false;\r\n\r\n  function setPosition(coords) {\r\n    let position = [];\r\n    let startX = Math.min(coords[0][0], coords[1][0]);\r\n    let startY = Math.min(coords[0][1], coords[1][1]);\r\n    let endX = Math.max(coords[0][0], coords[1][0]);\r\n    let endY = Math.max(coords[0][1], coords[1][1]);\r\n\r\n    if (startX > endX || endX > startX) {\r\n      let start = Math.min(startX, endX);\r\n      let end = Math.max(startX, endX);\r\n      for (let i = start; i <= end; i++) {\r\n        position.push({\r\n          x: i,\r\n          y: startY,\r\n          hit: false\r\n        });\r\n      }\r\n    }\r\n\r\n    if (startY > endY || endY > startY) {\r\n      let start = Math.min(startY, endY);\r\n      let end = Math.max(startY, endY);\r\n      for (let i = start; i <= end; i++) {\r\n        position.push({\r\n          x: startX,\r\n          y: i,\r\n          hit: false\r\n        });\r\n      }\r\n    }\r\n    return position;\r\n  }\r\n\r\n  function hit(coords) {\r\n    this.position.forEach(pos => {\r\n      if (pos.x == coords[0] && pos.y == coords[1]) {\r\n        pos.hit = true;\r\n      }\r\n    });\r\n    this.sunk = isSunk();\r\n  }\r\n\r\n  function isSunk() {\r\n    return position.filter(pos => pos.hit === false).length <= 0;\r\n  }\r\n\r\n  return { position, length, sunk, hit };\r\n};\r\n\r\nmodule.exports = Ship;\r\n\n\n//# sourceURL=webpack://battleship/./src/ship.js?");

/***/ }),

/***/ "./src/view.js":
/*!*********************!*\
  !*** ./src/view.js ***!
  \*********************/
/***/ ((module) => {

eval("const View = () => {\r\n  function renderBoard(gameBoard, selector, isPlayerBoard = true) {\r\n    const board = document.querySelector(selector);\r\n    // make sure we clear the board first before populating it again\r\n    clear(board);\r\n    gameBoard.getBoard().forEach(obj => {\r\n      const div = document.createElement('div');\r\n      div.setAttribute('data-x', obj.x);\r\n      div.setAttribute('data-y', obj.y);\r\n      // set classes for displaying ships only if it is the player board or already hit\r\n      if (isPlayerBoard || obj.isHit) {\r\n        if (obj.hasShip) div.classList.add('hasShip');\r\n      }\r\n      if (obj.isHit) div.classList.add('isHit');\r\n\r\n      board.appendChild(div);\r\n    });\r\n  }\r\n\r\n  function prepareGameBoard(selectors) {\r\n    const wrapper = document.querySelector('.main-wrapper');\r\n    clear(wrapper);\r\n    selectors.forEach(selector => {\r\n      const subWrapper = document.createElement('div');\r\n      subWrapper.classList.add(selector);\r\n      wrapper.appendChild(subWrapper);\r\n    });\r\n  }\r\n\r\n  function shipPlacement(gameBoard, selector) {\r\n    const board = document.querySelector(selector);\r\n    // make sure we clear the board first before populating it again\r\n    clear(board);\r\n    gameBoard.getBoard().forEach(obj => {\r\n      const div = document.createElement('div');\r\n      div.setAttribute('data-x', obj.x);\r\n      div.setAttribute('data-y', obj.y);\r\n      div.setAttribute('ondrop', 'drop(event)');\r\n      div.setAttribute('ondragover', 'allowDrop(event)');\r\n      // TODO: remove these once we can choose between random and manual placement\r\n      if (obj.hasShip) div.classList.add('hasShip');\r\n      if (obj.isHit) div.classList.add('isHit');\r\n\r\n      board.appendChild(div);\r\n    });\r\n  }\r\n\r\n  function clear(element) {\r\n    while (element.hasChildNodes()) {\r\n      element.lastChild.remove();\r\n    }\r\n  }\r\n\r\n  return { renderBoard, shipPlacement, prepareGameBoard };\r\n};\r\n\r\nmodule.exports = View;\r\n\n\n//# sourceURL=webpack://battleship/./src/view.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/game.js");
/******/ 	
/******/ })()
;